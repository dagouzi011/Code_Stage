# Complete SDE Stochastic Algae Control Model with OptimalControl Inputs

using OptimalControl
using NLPModelsIpopt
using Plots
using MadNLP
using DifferentialEquations
using Random

# ------------------ Parameters ------------------
kP = 1.6
K = 140.0
I0 = 300.0
α = 0.1
L = 50.0
kR_bar = 1.5
z_bar = 35.0
n = 3
σ = 0.05
tf = 100.0

# ------------------ Biological Functions ------------------
function I_light(z)
    return I0 * exp(-α * z)
end

function vP(p, z)
    return kP * p * I_light(z) / (K + p * I_light(z))
end

function kR(z)
    return kR_bar * z^n / (z_bar^n + z^n)
end

# ------------------ OptimalControl Solution ------------------
ocp = @def begin
    t ∈ [0, tf], time
    x = (c, p, z) ∈ R^3, state
    U ∈ R^2, control
    c(0) == 0.2
    p(0) == 0.2
    z(0) == 20.0
    0 ≤ U(t)[1] ≤ 1
    -1 ≤ U(t)[2] ≤ 1
    0 ≤ c(t) ≤ 1
    0 ≤ p(t) ≤ 1
    0 ≤ z(t) ≤ L
    c(t) + p(t) ≤ 1
    ẋ(t) == [
        vP(p(t), z(t)) * (1 - c(t)) - kR(z(t)) * c(t) * (1 - c(t) - p(t)),
        U(t)[1] * kR(z(t)) * c(t) * (1 - c(t) - p(t)) - vP(p(t), z(t)) * p(t),
        U(t)[2]
    ]
    ∫(vP(p(t), z(t))) → max
end

sol_ocp = solve(ocp, :direct, :adnlp, :ipopt, grid_size=500)
println("Maximum objective value ∫vP = ", objective(sol_ocp))
U_fun = control(sol_ocp)
u_fun = t -> U_fun(t)[1]
v_fun = t -> U_fun(t)[2]

# ------------------ SDE Definition ------------------
function f!(du, u, p, t)
    c, p_, z = u
    u_ctrl = clamp(u_fun(t), 0.0, 1.0)
    v_ctrl = clamp(v_fun(t), -1.0, 1.0)
    du[1] = vP(p_, z) * (1 - c) - kR(z) * c * (1 - c - p_)
    du[2] = u_ctrl * kR(z) * c * (1 - c - p_) - vP(p_, z) * p_
    du[3] = v_ctrl
end

function g!(du, u, p, t)
    du[1] = 0.0
    du[2] = 0.0
    du[3] = σ
end

# ------------------ SDE Solution ------------------
u0 = [0.2, 0.2, 20.0]
prob = SDEProblem(f!, g!, u0, (0.0, tf))
sol_sde = solve(prob, EM(), dt=0.01)

# ------------------ Results Visualization ------------------
times = sol_sde.t
c_vals = sol_sde[1, :]
p_vals = sol_sde[2, :]
z_vals = sol_sde[3, :]
u_vals = [clamp(u_fun(t), 0.0, 1.0) for t in times]
v_vals = [clamp(v_fun(t), -1.0, 1.0) for t in times]

plt1 = plot(times, c_vals, xlabel="Time (day)", ylabel="Value", label="c(t)", title="c(t) and p(t)")
plot!(plt1, times, p_vals, label="p(t)")
display(plt1)

plt2 = plot(times, u_vals, xlabel="Time (day)", ylabel="Control", label="u(t)", title="u(t) and v(t)")
plot!(plt2, times, v_vals, label="v(t)")
display(plt2)

# Identify prominent local maxima and minima of z(t)
using StatsBase
extrema_indices = findall(i -> (i > 1) && (i < length(z_vals)) && ((z_vals[i] > z_vals[i-1]) && (z_vals[i] > z_vals[i+1]) || (z_vals[i] < z_vals[i-1]) && (z_vals[i] < z_vals[i+1])), 1:length(z_vals))
max_indices = filter(i -> (z_vals[i] > z_vals[i-1]) && (z_vals[i] > z_vals[i+1]), extrema_indices)
min_indices = filter(i -> (z_vals[i] < z_vals[i-1]) && (z_vals[i] < z_vals[i+1]), extrema_indices)

# Select first 4 local maxima and minima in time
sorted_max_indices = max_indices[1:min(4, length(max_indices))]
sorted_min_indices = min_indices[1:min(4, length(min_indices))]

plt3 = plot(times, z_vals, xlabel="Time (day)", ylabel="Depth z (m)", title="z(t)", legend=false)
scatter!(plt3, times[sorted_max_indices], z_vals[sorted_max_indices], label="Maxima", color=:red)
scatter!(plt3, times[sorted_min_indices], z_vals[sorted_min_indices], label="Minima", color=:blue)
display(plt3)

println("First 4 local maxima of z(t) at times: ", times[sorted_max_indices])
println("First 4 local minima of z(t) at times: ", times[sorted_min_indices])
